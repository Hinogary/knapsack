<p><link rel="stylesheet" type="text/css" href="pandoc.css"/></p>
<h1 id="problém-batohu">Problém batohu</h1>
<h2 id="definice-problému">Definice problému</h2>
<p>Je daná množina předmětů s váhou a cenou. Úkolem je najít takovou podmnožinu, aby součet váh byl do maximální povolené váhy a zároveň celková cena podmnožiny byla maximální (konstrukční problém).</p>
<h2 id="implementace">Implementace</h2>
<p>Program je napsán v jazyce Rust. To je relativně nový jazyk. V rychlosti se mu daří konkurovat nízkoúrovnovým jazykům (ve většině benchmarcích vychází o trošku hůře než C++), ale píše se v něm spíše tak, že se to podobá vysokoúrovnovým. Má propracovaný pamětový model, a tak je to jeden z mála jazyků, který je pamětově bezpečný a zároveň nemá garbage collector.</p>
<p>Program se zkompiluje pomocí pomocného programu <code>cargo</code>, který je běžnou součástí jazyka. Funguje na stabilní verzi Rustu. Vybuildí se pomocí příkazu <code>cargo build --release</code> (to release je důležité kvůli optimalizacím, neoptimilizované programy jsou v rustu velmi pomalé).</p>
<p>Pro spuštění potřebuje argumenty, povinný je soubor se zadáním, volitelným argumentem je soubor pro kontrolu nalezených cen. Je v něm vestavěno měření času, ve kterém se počítá pouze čas pro rekurzivní navštěvovací funkci.</p>
<p>Je potřeba mu zadat, který engine má použít pro procházení prostoru. Aktuálně je k dispozici hrubá síla (pomocí argumentu <code>--naive</code>) a prořezávání (<code>--pruning</code>). Jde také vynutit kontrukční řešení pomocí <code>--force-construction</code>, ikdyž zadání říká, že by mělo být rozhodovací (opačně to nejde, protože chybí cílová cena).</p>
<p>Příklad zadání argumentů: <code>knapsack ../NR32_inst.dat --pruning</code></p>
<h2 id="výstup-programu">Výstup programu</h2>
<p>Na prvním řádku je <code>time</code>, to je čas na vyhodnocení jednoho problému, bez počítání doby na načtení a vypsání.</p>
<p>Na dalším řádku je vypsané řešení ve stejném formátu, v kterém je v zadání. Tedy postupně <code>id</code>, <code>size</code>, <code>cost</code> a <code>1/0</code> znázornující, jestli předmět do výsledké konfigurace patří a nebo nepatří. V případě nenalezení řešení v rozhodovacím problému je <code>cost</code> nula a bity znázurnující konfiguraci nejsou vypsány. V případě konstruktivní úlohy s porovnáváním, jestli našel správné řešení může být vypsána hláška <code>Same cost, but different solution!</code> - tedy výsledné naskládání předmětů bylo jiné, než v referenčním řešení, ale dalo to správnou cenu.</p>
<p>Na posledním řádku je Celkový čas, který je vypočítán jako součet všech <code>time</code> jednotlivých podúloh.</p>
<p>Algoritmy jsou <code>--naive</code>, <code>--pruning</code>, <code>--dynamic-weight</code>, <code>--dynamic-cost</code>, <code>--greedy</code> a <code>--redux</code>. Poslední řešič je <code>--ftpas</code>, který očekává číslo - vynucený dělitel, kterým se vydělí všechny ceny při výpočtu viz. v kapitole pro FTPAS.</p>
<pre><code>time: 60.762µs
493 25 28680 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1 0 1 1 0 0 0 1 1 1
time: 298ns
496 25 0
...
Maximum time: 1.420254ms Average time: 11.261µs
Total time: 5.630666ms</code></pre>
<h2 id="barvy-v-grafu">Barvy v grafu</h2>
<p><span style="color:red">Červená</span> je naivní, <span style="color:purple">fialová</span> prořezávání, <span style="color:blue">modrá</span> rozklad podle váhy a <span style="color:green">zelená</span> rozklad podle ceny. <span style="text-decoration: underline">Plná čára je průměr</span> a <span style="text-decoration:underline dotted">přerušovaná maximum</span>. Na grafech je čas v logaritmickém měřítku.</p>
<h2 id="vylepšení">Vylepšení</h2>
<p>Prořezávání prořezává mnohem lépe, proto sadu NK řeší mnohem rychleji, než implementace v 2. iteraci. Nově se bere v úvahu navíc zbývajicí cena a spočítá se přesně maximální dosáhnutelná cena v <span class="math inline"><em>O</em>(<em>l</em><em>n</em><em>n</em>)</span> času. To je možné tím, že mám pole součtu vah od určitého indexu do posledního, stejně s cenama. Poté binárně vyhledávám váhu takovou, že se akorát vejde zbývajicí kapacita. Vzhledem k tomu, že předměty jsou seřazený podle <code>cost/weight</code> ratia, tak když vemu předchozí předměty a poměrovou část poslední, tak to je maximální dosažitelná cena. Přikládám graf vylepšeného prořezávání na sadě NK. Během minulé iterace se prořezávání protínalo s rozkladem podle ceny. Sady <code>ZKC</code> a <code>ZKW</code> se téměř nezměnili.</p>
<p><img src="NK.png" /></p>
<p>Předměty se nově neřadí pouze podle <code>cost/weight</code> ratia, ale navíc se řadí od nejtěžšího po nejlehčí, pokud mají stejný poměr. To zaručí, že stejné předměty jsou vedle sebe a díky tomu je možné filtrovat permutace stejného předmětu v prořezávání (stejným předmětem se myslí předmět, co má stejnou cenu i váhu s jiným).</p>
<p>Jednotlivé algoritmy jsou nově rozdělené do jednotlivých souborů.</p>
<h2 id="naivní-implementace">Naivní implementace</h2>
<p>Naivní implementace je necitlivá na jakýkoliv kombinace cen, váh. Ta projde naivně všechny kombinaci a tedy se chová čistě exponencionálně - nemá smysl měřit vliv jednotlivých vstupů, protože jediné na co reaguje je velikost.</p>
<h2 id="robustnost">Robustnost</h2>
<p>Všechny zbývajicí metody přeuspořádají předměty podle <code>cost/weight</code> ratia primárně a podle váhy sekundárně (oboje sestupně). Vzhledem k tomu, že si předměty deterministicky seřadí před samotným spuštěním algoritmu, tak nemá smysl měřit vliv permutací, protože jediné co ovlivní je maximálně samotné řazení. V předchozí zprávě vycházel čas Reduxu maximálně <span class="math inline">8, 5<em>µ</em><em>s</em></span> (velikost instance 40). V této metodě je hlavní brzda právě samotné řazení - dá se očekávat, že řazení před spuštěním algoritmu se podílí na času při velikosti instance 40 přibližně takovýmhle časem. Všechny metody jsou tímto robustní a je zbytečné to experimentálně ověřovat.</p>
<h2 id="prvotní-testování-parametrů">Prvotní testování parametrů</h2>
<p>Na začátek zkusím vygenerovat instance (500) s výchozíma parametrama, maximální cenu i váhu nastavím na <span class="math inline">1000</span>, poměr kapacity/součtu <span class="math inline">0, 8</span> a velikosti jako byli v dodaných instancích, abych to uměl porovnat.</p>
<p><img src="PP.png" /></p>
<p>Podle očekávání tato sada dopadla srovnatelně s NK. Pojmenuji ji jako PP (první pokus).</p>
<h2 id="zvyšování-ceny-a-váhy">Zvyšování ceny a váhy</h2>
<p>Provedu 2 pokusy, první zvýšim jen maximální cenu na <span class="math inline">10 × 1000</span>, poté jen váhu. Předpoklad je, že takováta modifikace by měla vadit jen rozkladu podle ceny a váhy podle toho, co zvyšuji. Sada MC je s nastavením jako PP, akorát cena je na <span class="math inline">10000</span>. Sada MW obdobně pro váhu.</p>
<p><img src="MC.png" /></p>
<p><img src="MW.png" /></p>
<p>Dopadlo to podle očekávání - zvyšování ceny zhoršilo pouze čas na rozkladu podle ceny a zvyšování váhy pouze čas na rozkladu podle váhy.</p>
<h2 id="korelace-váhy-a-ceny">Korelace váhy a ceny</h2>
<p>Tady udělám 2 sady: CC a SC. CC je shodná s nastavením PP, ale korelace je na <code>corr</code>. SC má korelaci na <code>strong</code>. Předpoklad je, že nejvíce to bude vadit prořezávání a rozkladům by to nemělo vadit a nebo lehce pomoct.</p>
<p><img src="CC.png" /></p>
<p><img src="SC.png" /></p>
<p>Přesně podle předpokladu větší korelace zpomaluje prořezávání. Navíc trochu zpomaluje i rozklad podle ceny, protože tam mám taky ořezávání. Ikdyž je tam menší než v samotném prořezávání.</p>
<h2 id="poměr-kapacity-k-sumární-váze">Poměr kapacity k sumární váze</h2>
<p>V této sadě zafixuji velikost na 40 a budu hýbat s poměrem kapacity. Ostatní nastavení bude podle PP. Předpoklad je, že nějaký poměr bude nejtěžší a bude to okolo něho tvořit přibližně tvar normální rozdělení. Rozklady budou mít nejmenší hodnotu relativně vysoko díky větší konstantní složitosti a naopak prořezávání půjde k hodně malým číslům, jak bude moct mnohem lépe prořezávat. Navíc i rozklady by měli růst, ale jestli budou mít maxima nedokážu odhadnout.</p>
<p><img src="BR.png" /></p>
<p>Při nekorelované váze a ceně je tvar jiný, než jsem ho naměřil při pokusném spouštění. Proto zkusím ještě udělat datové soubory CR s SR (korelace na <code>corr</code> a <code>strong</code>).</p>
<p><img src="CR.png" /></p>
<p><img src="SR.png" /></p>
<p>Při nekorelované váze a ceně je nejdelší prořezávání asi okolo poměru <span class="math inline">0, 55</span>. Při korelované verzi je vrchol lehce nad <span class="math inline">0, 8</span>. Prořezávání je hodně citlivé na tento poměr a při vhodné korelaci se výpočet prodlouží.</p>
<p>Oba rozklady rostou přibližně lineárně s poměrem - což je efekt toho, že se zvyšuje lineárně maximální kapacita a maximální cena, zatímco předměty mají pořád stejný rozsah cen a vah.</p>
<h2 id="vliv-nepoměru-věcí">Vliv nepoměru věcí</h2>
<p>Předpokládám, že to nejvíc bude ovlivnovat prořezávání - tedy rovnou zafixuji korelaci na <code>corr</code> a <code>strong</code>. <span class="math inline"> − 1</span> v grafu odpovídá nastavení <code>light</code> a <span class="math inline"><em>k</em> = 1</span>. <span class="math inline">1</span> v grafu odpovídá nastavení <code>heavy</code> a <span class="math inline"><em>k</em> = 1</span>. 0 odpovídá nastavení <code>bal</code>. <code>CB</code> je typicky s korelací na <code>corr</code> a <code>SB</code> s korelací <code>strong</code>.</p>
<p><img src="CB.png" /></p>
<p><img src="SB.png" /></p>
<p>Vliv nepoměru věcí má spíše malý vliv. Rozklady se zvyšovali s tím, jak se zvyšovala maximální kapacita a cena. U prořezávání to záleželo na míře korelace, ale rozdíly mezi vyváženíma byli cca do <span class="math inline">2×</span>.</p>
<h2 id="závěr">Závěr</h2>
<p>Rozklad podle ceny je citlivý poze na maximální možnou cenu a velikost instance. Rozklad podle váhy stejně akorát na váhu.</p>
<p>V případě, že předměty nemají korelovanou váhu a cenu, tak bude vycházet nejlíp prořezávání - instance velikosti 40 zdaleka není limit.</p>
<p>V případě korelované váhy je nejtěžší obsazenost <span class="math inline">0, 8</span> kapacity. V případě nekorelované se to posune na <span class="math inline">0, 55</span>.</p>
<p>Nevyváženost má na celkový čas spíše malý vliv, u rozkladů jde vidět lehce lineární, ale ona zároveň stoupá maximální cena a kapacita batohu, když je více těžších předmětů. Prořezávání víc vyhovuje převaha těžších předmětů v případě silné korelace. Naopak lehce lehčí uvítá v případě slabší korelaci.</p>
